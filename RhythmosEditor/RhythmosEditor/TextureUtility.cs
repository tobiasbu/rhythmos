//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using UnityEditor;
using System.IO;
using System.Text;

namespace RhythmosEditor
{



	internal class TextureUtility {
		
		static public void FillTextureGradient( ref Texture2D texture, int x, int y, int width, int height, Color from, Color to) {
			
			
			for (int yy = 0; yy < height; yy++) {  
				for (int xx = 0; xx < width; xx++) {       
					
					
					Color ncolor = new Color();
					
					if (yy == 0) {
						
						ncolor = to;
						ncolor.a = to.a;
						
					} else if (yy == height-1) {
						
						
						ncolor = from;
						ncolor.a = from.a;
						
					} else {
						
						if (from != to) {
							
							float pct = (float)((height-1)-yy)/(height-1);
							
							//ncolor.r = Mathf.Lerp(from.r,to.r, pct);
							//ncolor.g = Mathf.Lerp(from.g,to.g, pct);
							//ncolor.b = Mathf.Lerp(from.b,to.b, pct);
							
							ncolor = Color.Lerp(from,to,pct);
							
							if (from.a != to.a)
								ncolor.a = Mathf.Lerp(from.a,to.a, pct);
							else
								ncolor.a = from.a;
							
						} else {
							
							ncolor = from;
							
						}
						
					}
					
					texture.SetPixel(x+xx, (yy+(texture.height-height))-y, ncolor);       
					
				}
			}
			
			texture.Apply();
			
			//return texture;
			
		}
		
		static public void FillTextureColor( ref Texture2D texture, int x, int y, int width, int height, Color color) {
			
			
			for (int yy = 0; yy < height; yy++) {  
				for (int xx = 0; xx < width; xx++) {       
					
					texture.SetPixel(x+xx, (yy+(texture.height-height))-y, color);       
					
				}
			}
			
			texture.Apply();
			
			//return texture;
			
		}
		
		static public Texture2D CreateTextureGradient(int width, int height, Color from, Color to) {
			
			Texture2D texture = new Texture2D(width, height); 
			
			FillTextureGradient(ref texture,0,0,width,height,from,to);
			
			texture.hideFlags = HideFlags.HideAndDontSave;
			
			return texture;
			
		}
		
		static public Texture2D CreateTexture(int width, int height, Color color) {
			
			Texture2D texture = new Texture2D(width, height); 
			
			FillTextureColor(ref texture,0,0,width,height,color);
			
			texture.hideFlags = HideFlags.HideAndDontSave;
			
			return texture;
			
		}
		
		static public Texture2D CreateSpecialDegrade(int width, int height, Color color) {
			
			Texture2D texture = new Texture2D(width, height); 
			
			//HSBColor hsbColor = new HSBColor(color);
			HSV hsvColorA;
			HSV hsvColorB;
			HSV hsvColorC;
			//Color.RGBToHSV(color,out hsvColorA.h,out hsvColorA.s,out hsvColorA.v);
			hsvColorA = Useful.RGBToHSV(color);
			hsvColorB = hsvColorA;
			hsvColorC = hsvColorA;

						
			if (hsvColorC.s == 0) {
				
				if (hsvColorA.v >= 1f)
					hsvColorA.v = hsvColorA.v-0.15f;
				
				hsvColorC.v = hsvColorA.v/0.7f;
				
				hsvColorB.v = hsvColorA.v*0.7f;
				
			} else {
				hsvColorC.s = 120f/255f;
				hsvColorC.v = 240f/255f;
				
				hsvColorA.s = 180f/255f;
				hsvColorA.v = 240f/255f;
				
				hsvColorB.s = 200f/255f;
				hsvColorB.v = 180f/255f;
				
			}

			Color cA = Useful.HSVToRGB (hsvColorA); //Color.HSVToRGB(hsvColorA.h,hsvColorA.s,hsvColorA.v);
			Color cB =  Useful.HSVToRGB(hsvColorB); //Color.HSVToRGB(hsvColorB.h,hsvColorB.s,hsvColorB.v);
			Color cC =  Useful.HSVToRGB(hsvColorC); //Color.HSVToRGB(hsvColorC.h,hsvColorC.s,hsvColorC.v);
			
			
			
			FillTextureColor(ref texture,0,0,width,height,cA);
			FillTextureGradient(ref texture,0,0,width,(int)(height/1.5f),cC,cA);
			FillTextureGradient(ref texture,0,height-height/6,width,height/6,cA,cB);
			
			
			texture.hideFlags = HideFlags.HideAndDontSave;
			
			//FillTextureBlock(ref texture,0,height/2,width,height,from,to);
			
			return texture;
			
		}
		
		static public Texture2D CreateOutlineBox(int width, int height,int borderSize,Color color, Color borderColor) {
			
			if (borderSize > 0) {
				
				int matrixsize = 3*borderSize;
				
				Texture2D texture = new Texture2D(width+matrixsize, height+matrixsize); 
				
				FillTextureColor(ref texture,0,0,width+matrixsize,height+matrixsize,color);
				
				width += matrixsize;
				height += matrixsize;
				
				// draw x
				for (int i = 0; i < borderSize; i++) {
					
					FillTextureColor(ref texture,0,i,width,1,borderColor);
					FillTextureColor(ref texture,0,height-(i+1),width,1,borderColor);
					
				}
				
				// draw y
				for (int i = 0; i < borderSize; i++) {
					
					FillTextureColor(ref texture,i,0,1,height,borderColor);
					FillTextureColor(ref texture,width-(i+1),0,1,height,borderColor);
					
				}
				
				return texture;
				
			} else {
				
				return null;
				
			}
			
		}
		
		static public void DrawLine(Texture2D tex, int x0, int y0, int x1, int y1, Color col)	{
			
			int dy = (int)(y1-y0);
			int dx = (int)(x1-x0);
			int stepx, stepy;
			
			if (dy < 0) {dy = -dy; stepy = -1;}
			else {stepy = 1;}
			if (dx < 0) {dx = -dx; stepx = -1;}
			else {stepx = 1;}
			dy <<= 1;
			dx <<= 1;
			
			float fraction = 0;
			
			tex.SetPixel(x0, y0, col);
			if (dx > dy) {
				fraction = dy - (dx >> 1);
				while (Mathf.Abs(x0 - x1) > 1) {
					if (fraction >= 0) {
						y0 += stepy;
						fraction -= dx;
					}
					x0 += stepx;
					fraction += dy;
					tex.SetPixel(x0, y0, col);
				}
			}
			else {
				fraction = dx - (dy >> 1);
				while (Mathf.Abs(y0 - y1) > 1) {
					if (fraction >= 0) {
						x0 += stepx;
						fraction -= dy;
					}
					y0 += stepy;
					fraction += dx;
					tex.SetPixel(x0, y0, col);
				}
			}
		}
		
		static public bool SaveBase64TextFile(string assetPath) {
			
			
			
			//File.OpenRead( XMLUtility.GetPathByPlatform() + assetPath);
			
			string fullpath = XMLUtility.GetPathByPlatform() + '/' + assetPath;
			
			if (File.Exists(fullpath)) {
				
				//FileStream stream;
				
				byte[] array = File.ReadAllBytes(fullpath);
				string encodedText = System.Convert.ToBase64String(array);
				
				
				//File.Create(Path.GetFileName(XMLUtility.GetPathByPlatform() + assetPath) + ".txt");
				
				File.WriteAllText( XMLUtility.GetPathByPlatform() + '/' + Path.GetFileName(fullpath) + ".txt",encodedText);
				
				Debug.Log("File " + XMLUtility.GetPathByPlatform() + '/' + Path.GetFileName(fullpath) + ".txt" + " saved!");
				
				return true;
				
			} else {
				
				Debug.LogError("File not found: " + fullpath);
				return false;
				
			}
			
		}
		
		static public Texture2D CreateFromBase64(string encodedText, HideFlags hide = HideFlags.HideAndDontSave) {
			
			byte[] array = System.Convert.FromBase64String(encodedText);
			
			Texture2D tex = new Texture2D(1,1);
			tex.LoadImage(array);
			tex.hideFlags = hide;
			
			return tex;
			
		}
		
		static public void DrawBox(Rect rect, Color color, ref Texture2D texture, float size) {
			
			GUI.color = color;
			
			GUI.DrawTexture(new Rect(rect.x,rect.y,rect.width,size), texture);
			GUI.DrawTexture(new Rect(rect.x,rect.y+rect.height-(size/2),rect.width,size), texture);
			
			GUI.DrawTexture(new Rect(rect.x,rect.y,size,rect.height), texture);
			GUI.DrawTexture(new Rect(rect.x+rect.width-(size/2),rect.y,size,rect.height+1), texture);
			
			GUI.color = Color.white;
			
		}
	}
}

